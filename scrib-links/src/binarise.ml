open Core.Std
open ScribbleAST
open SessionTypes

(* Symbol environment. Given a role name and recursion branch name,
 * generates a unique session type name. *)
let symEnv = object(self)
    val sym_env = Hashtbl.Poly.create ()

    method genName role rec_name =
      let cur_max_opt = Hashtbl.find sym_env (role, rec_name) in
      match cur_max_opt with
        | Some cur_max ->
            let new_max = cur_max + 1 in
            Hashtbl.set ~key:(role, rec_name) ~data:new_max sym_env;
            rec_name ^ (string_of_int new_max)
        | None ->
            Hashtbl.set ~key:(role, rec_name) ~data:0 sym_env;
            rec_name
    end
let gen_st_name proto_name role rec_name =
  proto_name ^ "_" ^ symEnv#genName role rec_name

let binarise proto_name role_name lty =
  (* Current session type name -> (RecVar |-> Session type name) ->
   * (Session type, Session type list)
   *)
  let rec binarise_inner : name -> (name * name) list -> local_type ->
    (binary_session_type * (name * binary_session_type) list) = fun ty_name env lty ->
    match lty with
    | `FLTSend interactions ->
        (match interactions with
           | [(_, msg, cont)] ->
               (* Binarise the inner type, collect any new types that may
                * be come out of the inner binarisation *)
               let (binarised_cont, gen_tys) = binarise_inner ty_name env cont in
               (`STSend (msg, binarised_cont), gen_tys)
           | xs ->
               (* Generate a choose guarded by each label, followed by a send *)
               (* Implemented as a fold: keep track of the types generated by each
                * binarisation. Process is similar for receives, too. *)
               let binarise_interaction (tys, branches) (_, (lbl, payloads), cont) =
                 let (binarised_cont, gen_tys) = binarise_inner ty_name env cont in
                 let new_branch =
                   (* Scribble doesn't have choice blocks, instead relying on guarded
                    * message choice. Instead, we project a choice, and each block then
                    * has a message where the data is conveyed. *)
                   (lbl, `STSend ((lbl, payloads), binarised_cont)) in
                 (tys @ gen_tys, new_branch :: branches) in
               let (tys, branches) = List.fold ~f:binarise_interaction ~init:([], []) xs in
               (`STChoose (List.rev branches), tys))
    | `FLTReceive (from, interactions) ->
        (match interactions with
           | [(msg, cont)] ->
               let (binarised_cont, gen_tys) = (binarise_inner ty_name env cont) in
               (`STReceive (msg, binarised_cont), gen_tys)
           | xs ->
               (* Generate a branch for each label, followed by a receive *)
               let binarise_interaction (tys, branches) ((lbl, payloads), cont) =
                 let (binarised_cont, gen_tys) = binarise_inner ty_name env cont in
                 let new_branch = (lbl, `STReceive ((lbl, payloads), binarised_cont)) in
                 (tys @ gen_tys, new_branch :: branches) in
               let (tys, branches) = List.fold ~f:binarise_interaction ~init:([], []) xs in
               (`STOffer (List.rev branches), tys))
    | `FLTMu (mu_name, cont) ->
        let st_name = (gen_st_name proto_name role_name mu_name) in
        (* Binarise the recursive type as a new type, then guard it with a recursive variable.
         * TODO: Do we even need to do this guarding stage? *)
        let (new_ty, tys) = binarise_inner st_name ((mu_name, st_name) :: env) cont in
        let guarded_new_ty = `STMu (st_name, new_ty) in
        (`STRecVar st_name, (st_name, guarded_new_ty) :: tys)
    | `FLTRecVar x ->
        let st_name_opt = List.Assoc.find env x in
        (match st_name_opt with
           | Some st_name -> (`STRecVar st_name, [])
           | None -> failwith ("Rec var " ^ x ^ " not in environment"))
    | `FLTEnd -> (`STEnd, []) in
  let (outer_ty, tys) = binarise_inner proto_name [] lty in
  let ty_name = proto_name ^ "_" ^ role_name in
  (ty_name, outer_ty) :: tys

